# Using a Render Pipeline to Render Primitives
# 使用渲染管道渲染基本体

Render a simple 2D triangle.

渲染一个简单的二维三角形。

## Overview

In [Using Metal to Draw a View’s Contents](https://developer.apple.com/documentation/metal/basic_tasks_and_concepts/using_metal_to_draw_a_view_s_contents), you learned how to set up an `MTKView` object and to change the view's contents using a render pass.
That sample simply erased the view's contents to a background color.
This sample shows you how to configure a render pipeline and use it as part of the render pass to draw a simple 2D colored triangle into the view.
The sample supplies a position and color for each vertex, and the render pipeline uses that data to render the triangle, interpolating color values between the colors specified for the triangle's vertices.

在<Using Metal to Draw a View’s Contents>该节中，您学习了如何设置MTKView对象以及如何使用渲染过程更改视图的内容，只是将视图的内容清除为背景色。此示例演示如何配置渲染管道，并将其用作渲染过程的一部分，以便在视图中绘制一个简单的二维彩色三角形。该示例为每个顶点提供位置和颜色，渲染管道使用该数据渲染三角形，在为三角形顶点指定的颜色之间插值颜色值。

![Simple 2D Triangle Vertices](Documentation/2DTriangleVertices.png)

- Note: The Xcode project contains schemes for running the sample on macOS, iOS, and tvOS.
Metal isn't supported in the iOS or tvOS Simulator, so the iOS and tvOS schemes require a physical device to run the sample.
The default scheme is macOS.

- Note: Xcode项目包含在macOS、iOS和tvOS上运行示例的方案。
在iOS或tvOS模拟器中不支持Metal(Metal 3.0后iOS模拟器支持运行部分代码了)，因此iOS和tvOS方案需要一个物理设备来运行示例。
默认方案是macOS。

## Understand the Metal Render Pipeline
## 了解Metal渲染管道

A *render pipeline* processes drawing commands and writes data into a render pass’s targets.
 A render pipeline has many stages, some programmed using shaders and others with fixed or configurable behavior.
This sample focuses on the three main stages of the pipeline: the vertex stage, the rasterization stage, and the fragment stage.
The vertex stage and fragment stage are programmable, so you write functions for them in Metal Shading Language (MSL).
The rasterization stage has fixed behavior.

渲染管道处理图形命令并将数据写入渲染过程的目标（纹理）。
渲染管道有许多阶段，其中一些阶段使用着色器编程，而其他阶段具有固定或可配置的行为。
此示例集中于管道的三个主要阶段：顶点阶段、光栅化阶段和碎片阶段。
顶点阶段和碎片阶段是可编程的，因此您可以用Metal Shading Language（MSL）为它们编写函数。
光栅化阶段有固定的行为。


**Figure 1** Main stages of the Metal graphics render pipeline

**图1** 图形渲染管道的主要阶段

![Main Stages of the Metal Graphics Render Pipeline](Documentation/SimplePipeline.png)

Rendering starts with a drawing command, which includes a vertex count and what kind of primitive to render. For example, here's the drawing command from this sample:

渲染从绘图命令开始，该命令包括顶点计数和要渲染的基本体类型。例如，以下是来自此示例的绘图命令：

``` objective-c
// Draw the triangle.
[renderEncoder drawPrimitives:MTLPrimitiveTypeTriangle
                  vertexStart:0
                  vertexCount:3];
```

The vertex stage provides data for each vertex. When enough vertices have been processed, the render pipeline rasterizes the primitive, determining which pixels in the render targets lie within the boundaries of the primitive. The fragment stage determines the values to write into the render targets for those pixels.

顶点阶段为每个顶点提供数据。处理了足够多的顶点后，渲染管道将 栅格化 基本体，确定渲染目标中哪些像素位于基本体的边界内。片段阶段确定要写入这些像素的渲染目标的值。

In the rest of this sample, you will see how to write the vertex and fragment functions, how to create the render pipeline state object, and finally, how to encode a draw command that uses this pipeline.

在本示例的其余部分中，您将看到如何编写顶点和片段函数，如何创建渲染管道状态对象，最后，如何对使用此管道的绘画命令进行编码。

## Decide How Data is Processed by Your Custom Render Pipeline
## 决定自定义渲染管道如何处理数据

A vertex function generates data for a single vertex and a fragment function generates data for a single fragment, but you decide how they work.

顶点函数为单个顶点生成数据，片段函数为单个片段生成数据，但由您决定它们的工作方式。

You configure the stages of the pipeline with a goal in mind, meaning that you know what you want the pipeline to generate and how it generates those results.

在配置管道的各个阶段时，要记住一个目标，这意味着您知道希望管道生成什么以及它如何生成这些结果。

Decide what data to pass into your render pipeline and what data is passed to later stages of the pipeline. There are typically three places where you do this:

决定哪些数据要传递到渲染管道中，哪些数据将传递到管道的后期阶段。通常有三个位置可以执行此操作：

- The inputs to the pipeline, which are provided by your app and passed to the vertex stage.
- 管道的输入，由应用程序提供并传递到顶点阶段。
- The outputs of the vertex stage, which is passed to the rasterization stage.
- 顶点阶段的输出，它被传递到光栅化阶段。
- The inputs to the fragment stage, which are provided by your app or generated by the rasterization stage.
- 片段阶段的输入，这些输入由应用程序提供或由光栅化阶段生成。

In this sample, the input data for the pipeline is the position of a vertex and its color. To demonstrate the kind of transformation you typically perform in a vertex function, input coordinates are defined in a custom coordinate space, measured in pixels from the center of the view. These coordinates need to be translated into Metal's coordinate system.

在本示例中，管道的输入数据是顶点的位置及其颜色。为了演示通常在顶点函数中执行的变换，输入坐标在自定义坐标空间中定义，以距视图中心的像素为单位。这些坐标需要转换成Metal的坐标系。

Declare an `AAPLVertex` structure, using SIMD vector types to hold the position and color data.
To share a single definition for how the structure is laid out in memory, declare the structure in a common header and import it in both the Metal shader and the app.

声明一个“AAPLVertex”结构，使用SIMD向量类型保存位置和颜色数据。
若要共享结构在内存中的布局方式的单个定义，请在公共标头中声明该结构，然后在Metal着色器和应用程序中导入该结构。

``` objective-c
typedef struct
{
    vector_float2 position;
    vector_float4 color;
} AAPLVertex;
```

SIMD types are commonplace in Metal Shading Language, and you should also use them in your app using the simd library.
SIMD types contain multiple channels of a particular data type, so declaring the position as a `vector_float2` means it contains two 32-bit float values (which will hold the x and y coordinates.)
Colors are stored using a `vector_float4`, so they have four channels – red, green, blue, and alpha.

SIMD类型在Metal着色语言中很常见，您也应该在应用程序中使用SIMD库。
SIMD类型包含特定数据类型的多个通道，因此将位置声明为“vector_float2”意味着它包含两个32位浮点值（将保存x和y坐标），
颜色使用“vector_float4”存储，因此它们有四个通道–红色、绿色、蓝色和alpha。

In the app, the input data is specified using a constant array:

在应用程序中，使用常量数组指定输入数据：

``` objective-c
static const AAPLVertex triangleVertices[] =
{
    // 2D positions,    RGBA colors
    { {  250,  -250 }, { 1, 0, 0, 1 } },
    { { -250,  -250 }, { 0, 1, 0, 1 } },
    { {    0,   250 }, { 0, 0, 1, 1 } },
};
```

The vertex stage generates data for a vertex, so it needs to provide a color and a transformed position.
Declare a `RasterizerData` structure containing a position and a color value, again using SIMD types. 

顶点阶段为顶点生成数据，因此需要提供颜色和变换后的位置。
再次使用SIMD类型声明一个包含位置和颜色值的“RasterizerData”结构。

``` metal
typedef struct
{
    // The [[position]] attribute of this member indicates that this value
    // is the clip space position of the vertex when this structure is
    // returned from the vertex function.
    // 此成员的[[position]]属性表示该值是从vertex函数返回此结构时顶点的剪辑空间位置。
    float4 position [[position]];

    // Since this member does not have a special attribute, the rasterizer
    // interpolates its value with the values of the other triangle vertices
    // and then passes the interpolated value to the fragment shader for each
    // fragment in the triangle.
    // 由于该成员没有特殊属性，光栅化器使用其他三角形顶点的值对其值进行插值，然后将插值值传递给三角形中每个片段的片段着色器。
    float4 color;

} RasterizerData;
```

The output position (described in detail below) must be defined as a `vector_float4`. The color is declared as it was in the input data structure.

输出位置（下面详细描述）必须定义为“vector_float4”。在输入数据结构中声明颜色。

You need to tell Metal which field in the rasterization data provides position data, because Metal doesn't enforce any particular naming convention for fields in your struct.
Annotate the `position` field with the `[[position]]` attribute qualifier to declare that this field holds the output position.

您需要告诉Metal光栅化数据中的哪个字段提供位置数据，因为Metal不为结构中的字段强制任何特定的命名约定。
用`[[position]]`属性限定符注释“position”字段，以声明此字段保留输出位置。

The fragment function simply passes the rasterization stage's data to later stages so it doesn't need any additional arguments.

片段函数只是将光栅化阶段的数据传递给后面的阶段，因此它不需要任何额外的参数。

## Declare the Vertex Function
## 声明顶点函数

Declare the vertex function, including its input arguments and the data it outputs.
Much like compute functions were declared using the `kernel` keyword, you declare a vertex function using the `vertex` keyword.

声明vertex函数，包括它的输入参数和它输出的数据。
就像使用“kernel”关键字声明计算函数一样，使用“vertex”关键字声明顶点函数。

``` metal
vertex RasterizerData
vertexShader(uint vertexID [[vertex_id]],
             constant AAPLVertex *vertices [[buffer(AAPLVertexInputIndexVertices)]],
             constant vector_uint2 *viewportSizePointer [[buffer(AAPLVertexInputIndexViewportSize)]])
```

The first argument, `vertexID`, uses the `[[vertex_id]]` attribute qualifier, which is another Metal keyword.
When you execute a render command, the GPU calls your vertex function multiple times, generating a unique value for each vertex.

第一个参数“vertexID”使用“[[vertex_id]]`属性限定符，这是另一个Metal关键字。
执行渲染命令时，GPU会多次调用顶点函数，为每个顶点生成一个唯一的值。

The second argument, `vertices`, is an array that contains the vertex data, using the `AAPLVertex` struct previously defined.

第二个参数“vertices”是一个包含顶点数据的数组，使用前面定义的“AAPLVertex”结构。

To transform the position into Metal's coordinates, the function needs the size of the viewport (in pixels) that the triangle is being drawn into, so this is stored in the `viewportSizePointer` argument.

要将位置转换为Metal的坐标，函数需要绘制三角形的视口的大小（以像素为单位），因此它存储在“viewportSizePointer”参数中。

The second and third arguments have the `[[buffer(n)]]` attribute qualifier.
By default, Metal assigns slots in the argument table for each parameter automatically.
When you add the `[[buffer(n)]]` qualifier to a buffer argument, you tell Metal explicitly which slot to use.
Declaring slots explicitly can make it easier to revise your shaders without also needing to change your app code.
Declare the constants for the two indicies in the shared header file.

第二个和第三个参数具有“[[buffer（n）]]”属性限定符。
默认情况下，Metal会自动在参数表中为每个参数指定插槽。
向缓冲区参数添加“[[buffer（n）]]”限定符时，您将明确告诉Metal要使用哪个插槽。
显式声明槽可以使修改着色器更容易，而无需更改应用程序代码。
在共享头文件中声明两个指示符的常量。

The function's output is a `RasterizerData` struct.

函数的输出是一个“RasterizerData”结构。

## Write the Vertex Function
## 写顶点函数

Your vertex function must generate both fields of the output struct. 
Use the `vertexID` argument to index into the `vertices` array and read the input data for the vertex.
Also, retrieve the viewport dimensions.

顶点函数必须生成输出结构的两个字段。
使用“vertexID”参数索引到“vertexID”数组并读取顶点的输入数据。
此外，检索视口尺寸。

``` metal
float2 pixelSpacePosition = vertices[vertexID].position.xy;

// Get the viewport size and cast to float.
vector_float2 viewportSize = vector_float2(*viewportSizePointer);

```

Vertex functions must provide position data in *clip-space coordinates*, which are 3D points specified using a four-dimensional homogenous vector (`x,y,z,w`). The rasterization stage takes the output position and divides the `x`,`y`, and `z` coordinates by `w` to generate a 3D point in *normalized device coordinates*. Normalized device coordinates are independent of viewport size.

顶点函数必须以*剪辑空间坐标*提供位置数据，这些坐标是使用四维同构向量（`x，y，z，w`）指定的三维点。光栅化阶段获取输出位置，将“x”、“y”和“z”坐标除以“w”，在*标准化设备坐标*中生成一个三维点。标准化设备坐标与视口大小无关。

**Figure 2** Normalized device coordinate system

**图2** 标准化设备坐标系

![Normalized device coordinate system](Documentation/normalizeddevicecoords.png)

Normalized device coordinates use a *left-handed coordinate system* and map to positions in the viewport.
Primitives are clipped to a box in this coordinate system and then rasterized.
The lower-left corner of the clipping box is at an `(x,y)` coordinate of `(-1.0,-1.0)` and the upper-right corner is at `(1.0,1.0)`.
Positive-z values point away from the camera (into the screen.)
The visible portion of the `z` coordinate is between `0.0` (the near clipping plane) and `1.0` (the far clipping plane).

标准化设备坐标使用*左手坐标系*并映射到视口中的位置。
基本体被剪裁到这个坐标系中的一个长方体，然后栅格化。
剪辑框的左下角位于`（-1.0，-1.0）`（x，y）`坐标，右上角位于`（1.0,1.0）`。
正z值指向远离摄影机（进入屏幕）
“z”坐标的可见部分在“0.0”（近剪裁平面）和“1.0”（远剪裁平面）之间。

Transform the input coordinate system to the normalized device coordinate system.

将输入坐标系转换为标准化设备坐标系。

![Vertex function coordinate transformation](Documentation/metal-coordinate-transformation.png)

Because this is a 2D application and does not need homogenous coordinates, first write a default value to the output coordinate, with the the `w` value is set to `1.0` and the other coordinates set to `0.0`.
This means that the coordinates are already in the normalized device coordinate space and the vertex function should generate (x,y) coordinates in that coordinate space.
Divide the input position by half the viewport size to generate normalized device coordinates.
Since this calculation is performed using SIMD types, both channels can be divided at the same time using a single line of code.
Perform the divide and put the results in the x and y channels of the output position. 

因为这是一个二维应用程序，不需要同质坐标，所以首先向输出坐标写入一个默认值，“w”值设置为“1.0”，其他坐标设置为“0.0”。
这意味着坐标已经在标准化设备坐标空间中，顶点函数应该在该坐标空间中生成（x，y）坐标。
将输入位置除以视口大小的一半以生成标准化设备坐标。
由于此计算是使用SIMD类型执行的，因此可以使用一行代码同时分割两个通道。
执行除法并将结果放入输出位置的x和y通道中。

``` metal
out.position = vector_float4(0.0, 0.0, 0.0, 1.0);
out.position.xy = pixelSpacePosition / (viewportSize / 2.0);
```

Finally, copy the color value into the `out.color` return value.

最后，将颜色值复制到`out.color`返回值。

``` metal
out.color = vertices[vertexID].color;
```

## Write a Fragment Function
## 编写片段函数

A *fragment* is a possible change to the render targets. The rasterizer determines which pixels of the render target are covered by the primitive.
Only fragments whose pixel centers are inside the triangle are rendered.

*fragment*是对渲染目标的可能更改。光栅化器确定基本体覆盖渲染目标的哪些像素。
仅渲染像素中心位于三角形内部的片段。

**Figure 3** Fragments generated by the rasterization stage

**图3** 光栅化阶段产生的碎片

![Fragments generated by the rasterization stage](Documentation/Rasterization.png)

A fragment function processes incoming information from the rasterizer for a single position and calculates output values for each of the render targets. These fragment values are processed by later stages in the pipeline, eventually being written to the render targets.

fragment函数处理来自光栅化器的单个位置的传入信息，并计算每个渲染目标的输出值。这些片段值由管道的后期处理，最终写入呈现目标。

- Note: The reason a fragment is called a possible change is because the pipeline stages after the fragment stage can be configured to reject some fragments or change what gets written to the render targets. In this sample, all values calculated by the fragment stage are written as-is to the render target.

- 笔记:之所以将片段称为可能的更改，是因为片段阶段之后的管道阶段可以配置为拒绝某些片段或更改写入呈现目标的内容。在此示例中，由片段阶段计算的所有值都按原样写入呈现目标。

The fragment shader in this sample receives the same parameters that were declared in the vertex shader's output. Declare the fragment function using the `fragment` keyword. It takes a single argument, the same `RasterizerData` structure that was provided by the vertex stage. Add the `[[stage_in]]` attribute qualifier to indicate that this argument is generated by the rasterizer.

此示例中的片段着色器接收的参数与顶点着色器输出中声明的参数相同。使用“fragment”关键字声明fragment函数。它接受一个参数，与顶点阶段提供的“RasterizerData”结构相同。添加“[[stage_in]]”属性限定符，以指示此参数是由光栅化器生成的。

``` metal
fragment float4 fragmentShader(RasterizerData in [[stage_in]])
```

If your fragment function writes to multiple render targets, it must declare a struct with fields for each render target.
Because this sample only has a single render target, you specify a floating-point vector directly as the function's output. This output is the color to be written to the render target.

如果片段函数写入多个呈现目标，则它必须为每个呈现目标声明一个包含字段的结构。
由于此示例只有一个渲染目标，因此可以直接指定浮点向量作为函数的输出。此输出是要写入渲染目标的颜色。

The rasterization stage calculates values for each fragment's arguments and calls the fragment function with them.
The rasterization stage calculates its color argument as a blend of the colors at the triangle's vertices.
The closer a fragment is to a vertex, the more that vertex contributes to the final color.

光栅化阶段为每个片段的参数计算值并调用片段函数。
光栅化阶段将其颜色参数计算为三角形顶点处颜色的混合。
片段离顶点越近，顶点对最终颜色的贡献就越大。

**Figure 4** Interpolated fragment colors

**图4** 插值片段颜色

![Interpolated Fragment Colors](Documentation/Interpolation.png)

Return the interpolated color as the function's output. 

返回插值颜色作为函数的输出。

``` metal
return in.color;
```

## Create a Render Pipeline State Object
## 创建渲染管道状态对象

Now that the functions are complete, you can create a render pipeline that uses them.
First, get the default library and obtain a [`MTLFunction`][MTLFunction] object for each function.

现在函数已经完成，可以创建使用它们的渲染管道。
首先，获取默认库并为每个函数获取一个[`MTLFunction`][MTLFunction]对象。

``` objective-c
id<MTLLibrary> defaultLibrary = [_device newDefaultLibrary];

id<MTLFunction> vertexFunction = [defaultLibrary newFunctionWithName:@"vertexShader"];
id<MTLFunction> fragmentFunction = [defaultLibrary newFunctionWithName:@"fragmentShader"];
```

Next, create a [`MTLRenderPipelineState`][MTLRenderPipelineState] object.
Render pipelines have more stages to configure, so you use a [`MTLRenderPipelineDescriptor`][MTLRenderPipelineDescriptor] to configure the pipeline.

接下来，创建一个[`MTLRenderPipelineState`][MTLRenderPipelineState]对象。
呈现管道有更多的后台文件要配置，因此可以使用[`MTLRenderPipelineDescriptor`][MTLRenderPipelineDescriptor]来配置管道。

``` objective-c
MTLRenderPipelineDescriptor *pipelineStateDescriptor = [[MTLRenderPipelineDescriptor alloc] init];
pipelineStateDescriptor.label = @"Simple Pipeline";
pipelineStateDescriptor.vertexFunction = vertexFunction;
pipelineStateDescriptor.fragmentFunction = fragmentFunction;
pipelineStateDescriptor.colorAttachments[0].pixelFormat = mtkView.colorPixelFormat;

_pipelineState = [_device newRenderPipelineStateWithDescriptor:pipelineStateDescriptor
                                                         error:&error];
```

In addition to specifying the vertex and fragment functions, you also declare the *pixel format* of all render targets that the pipeline will draw into.
A pixel format ([`MTLPixelFormat`][MTLPixelFormat]) defines the memory layout of pixel data.
For simple formats, this definition includes the number of bytes per pixel, the number of channels of data stored in a pixel, and the bit layout of those channels.
Since this sample only has one render target and it is provided by the view, copy the view's pixel format into the render pipeline descriptor.
Your render pipeline state must use a pixel format that is compatible with the one specified by the render pass.
In this sample, the render pass and the pipeline state object both use the view's pixel format, so they are always the same.

除了指定vertex和fragment函数外，还声明管道将绘制到的所有渲染目标的*pixel format*。
像素格式（[`MTLPixelFormat`][MTLPixelFormat]）定义像素数据的内存布局。
对于简单格式，此定义包括每个像素的字节数、存储在一个像素中的数据通道数以及这些通道的位布局。
由于此示例只有一个渲染目标，并且由视图提供，请将视图的像素格式复制到渲染管道描述符中。
渲染管道状态必须使用与渲染过程指定的像素格式兼容的像素格式。
在本示例中，渲染过程和管道状态对象都使用视图的像素格式，因此它们始终相同。

When Metal creates the render pipeline state object, the pipeline is configured to convert the fragment function's output into the render target's pixel format.
If you want to target a different pixel format, you need to create a different pipeline state object.
You can reuse the same shaders in multiple pipelines targeting different pixel formats.

当Metal创建渲染管道状态对象时，管道配置为将片段函数的输出转换为渲染目标的像素格式。
如果您希望以不同的像素格式为目标，则需要创建不同的管道状态对象。
可以在多个针对不同像素格式的管道中重用相同的着色器。

## Set a Viewport
## 设置视口

Now that you have the render pipeline state object for the pipeline, you'll render the triangle. You do this using a render command encoder. First, set the viewport, so that Metal knows which part of the render target you want to draw into.

现在已经有了管道的render pipeline state对象，接下来将渲染三角形。可以使用渲染命令编码器执行此操作。首先，设置视口，以便Metal知道要绘制到渲染目标的哪个部分。

``` objective-c
// Set the region of the drawable to draw into.
// 设置绘图区域。
[renderEncoder setViewport:(MTLViewport){0.0, 0.0, _viewportSize.x, _viewportSize.y, 0.0, 1.0 }];
```

## Set the Render Pipeline State
## 设置渲染管道状态

Set the render pipeline state for the pipeline you want to use.

为要使用的管道设置渲染管道状态。

``` objective-c
[renderEncoder setRenderPipelineState:_pipelineState];
```

## Send Argument Data to the Vertex Function
## 将参数数据发送到顶点函数

Often, you use buffers ([`MTLBuffer`][MTLBuffer]) to pass data to shaders.
However, when you need to pass only a small amount of data to the vertex function, as is the case here, copy the data directly into the command buffer.

通常，使用缓冲区（[`MTLBuffer`][MTLBuffer]）将数据传递到着色器。
但是，当您只需要向vertex函数传递少量数据时（如这里所示），请将数据直接复制到命令缓冲区中。

The sample copies data for both parameters into the command buffer.
The vertex data is copied from an array defined in the sample.
The viewport data is copied from the same variable that you used to set the viewport. 

该示例将两个参数的数据复制到命令缓冲区。
顶点数据是从示例中定义的数组复制的。
视口数据是从用于设置视口的同一变量复制的。

In this sample, the fragment function uses only the data it receives from the rasterizer, so there are no arguments to set.

在这个示例中，片段函数只使用它从光栅化器接收的数据，因此没有要设置的参数。

``` objective-c
[renderEncoder setVertexBytes:triangleVertices
                       length:sizeof(triangleVertices)
                      atIndex:AAPLVertexInputIndexVertices];

[renderEncoder setVertexBytes:&_viewportSize
                       length:sizeof(_viewportSize)
                      atIndex:AAPLVertexInputIndexViewportSize];
```


## Encode the Drawing Command
## 编码绘图命令

Specify the kind of primitive, the starting index, and the number of vertices.
When the triangle is rendered, the vertex function is called with values of 0, 1, and 2 for the `vertexID` argument.

指定基本体的类型、起始索引和顶点数。
当呈现三角形时，vertexID参数的值为0、1和2调用vertex函数。

``` objective-c
// Draw the triangle.
[renderEncoder drawPrimitives:MTLPrimitiveTypeTriangle
                  vertexStart:0
                  vertexCount:3];
```

As with Drawing to the Screen Using Metal, you end the encoding process and commit the command buffer.
However, you could encode more render commands using the same set of steps.
The final image is rendered as if the commands were processed in the order they were specified.
(For performance, the GPU is allowed to process commands or even parts of commands in parallel, so long as the final result appears to have been rendered in order. )

与使用Metal绘制到屏幕一样，结束编码过程并提交命令缓冲区。
但是，可以使用相同的一组步骤对更多渲染命令进行编码。
最终图像的呈现方式与命令的指定顺序相同。
（为了提高性能，GPU可以并行处理命令甚至部分命令，只要最终结果看起来是按顺序呈现的）

## Experiment with the Color Interpolation
## 尝试颜色插值

In this sample, color values were interpolated across the triangle.
That's often what you want, but sometimes you want a value to be generated by one vertex and remain constant across the whole primitive.
Specify the `flat` attribute qualifier on an output of the vertex function to do this.
Try this now.
Find the definition of `RasterizerData` in the sample project and add the `[[flat]]` qualifier to its `color` field.

在此示例中，颜色值是通过三角形插值的。
这通常是您想要的，但有时您希望一个值由一个顶点生成，并在整个基本体中保持不变。
为此，请在vertex函数的输出上指定“flat”属性限定符。
现在试试这个。
在示例项目中找到“RasterizerData”的定义，并将“[[flat]]`限定符添加到其“color”字段中。

`float4 color [[flat]];`

Run the sample again.
The render pipeline uses the color value from the first vertex (called the *provoking vertex*) uniformly across the triangle, and it ignores the colors from the other two vertices.
You can use a mix of flat shaded and interpolated values, simply by adding or omitting the `flat` qualifier on your vertex function's outputs.
The [Metal Shading Language specification][ShadingLanguageSpec] defines other attribute qualifiers you can also use to modify the rasterization behavior.

再次运行样本。
渲染管道使用来自第一个顶点（称为*激发顶点*）的颜色值，并忽略其他两个顶点的颜色。
只需在顶点函数的输出上添加或省略“flat”限定符，就可以混合使用平面着色和插值值。
[Metal Shading Language specification][ShadingLanguageSpec]定义了其他属性限定符，也可以用来修改光栅化行为。

[ScreenDrawing]: https://developer.apple.com/documentation/metal
[MTLDevice]: https://developer.apple.com/documentation/metal/mtldevice
[MTLResource]: https://developer.apple.com/documentation/metal/mtlresource
[MTLBuffer]: https://developer.apple.com/documentation/metal/mtlbuffer
[MTLRenderPipelineState]: https://developer.apple.com/documentation/metal/mtlrenderpipelinestate
[MTLRenderPipelineDescriptor]: https://developer.apple.com/documentation/metal/mtlrenderpipelinedescriptor
[MTLRenderCommandEncoder]: https://developer.apple.com/documentation/metal/mtlrendercommandencoder
[MTLPixelFormat]: https://developer.apple.com/documentation/metal/mtlpixelformat
[MTKView]: https://developer.apple.com/documentation/metalkit/mtkview
[ShadingLanguageSpec]: https://developer.apple.com/metal/Metal-Shading-Language-Specification.pdf
[MTLFunction]: https://developer.apple.com/documentation/metal/mtlfunction
